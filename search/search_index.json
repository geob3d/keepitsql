{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to KeepItSql","text":"<p>Getting Started with KeepItSQL</p> <p>Welcome to KeepItSQL, a powerful package designed to generate SQL syntax from a dataframe. This package simplifies SQL operations by automatically creating INSERT and UPSERT statements based on your dataframe and the target database.</p>"},{"location":"#installation","title":"Installation","text":"<p>First, you need to install the KeepItSQL package. If it\u2019s available on PyPI, you can install it using pip:</p> <pre><code>pip install keepitsql\n</code></pre> <p>If it\u2019s not available on PyPI, you can install it directly from the source:</p> <pre><code>git clone https://github.com/your-repo/keepitsql.git\ncd keepitsql\npip install .\n</code></pre>"},{"location":"#modules-overview","title":"Modules Overview","text":"<p>KeepItSQL provides two main functionalities:</p> <pre><code>\u2022   Insert: Generates an INSERT statement from a dataframe.\n\u2022   Upsert: Generates an UPSERT statement, which can be either a MERGE or INSERT ON CONFLICT statement, based on the database type.\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#commands","title":"Commands","text":"<p>I want to thank my house plants for providing me with a negligible amount of oxygen each day. Also, I want to thank the sun for providing more than half of their nourishment free of charge.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#keepitsql.core.from_dataframe.FromDataframe","title":"<code>FromDataframe</code>","text":"<p>               Bases: <code>Upsert</code>, <code>Insert</code></p> Source code in <code>keepitsql/core/from_dataframe.py</code> <pre><code>class FromDataframe(Upsert, Insert):\n    def __init__(self, target_table, dataframe, target_schema=None):\n        \"\"\"Initializes a new instance of the FromDataframe class.\n\n        Parameters\n        ----------\n        - target_table: str. The name of the target table for SQL operations.\n        - dataframe: DataFrame. The dataframe containing the data to be upserted.\n        - target_schema: str, optional. The schema of the target table, if applicable.\n        \"\"\"\n        super().__init__(target_table, target_schema, dataframe)\n</code></pre>"},{"location":"reference/#keepitsql.core.from_dataframe.FromDataframe.__init__","title":"<code>__init__(target_table, dataframe, target_schema=None)</code>","text":"<p>Initializes a new instance of the FromDataframe class.</p>"},{"location":"reference/#keepitsql.core.from_dataframe.FromDataframe.__init__--parameters","title":"Parameters","text":"<ul> <li>target_table: str. The name of the target table for SQL operations.</li> <li>dataframe: DataFrame. The dataframe containing the data to be upserted.</li> <li>target_schema: str, optional. The schema of the target table, if applicable.</li> </ul> Source code in <code>keepitsql/core/from_dataframe.py</code> <pre><code>def __init__(self, target_table, dataframe, target_schema=None):\n    \"\"\"Initializes a new instance of the FromDataframe class.\n\n    Parameters\n    ----------\n    - target_table: str. The name of the target table for SQL operations.\n    - dataframe: DataFrame. The dataframe containing the data to be upserted.\n    - target_schema: str, optional. The schema of the target table, if applicable.\n    \"\"\"\n    super().__init__(target_table, target_schema, dataframe)\n</code></pre>"},{"location":"reference/#keepitsql.core.insert.Insert","title":"<code>Insert</code>","text":"Source code in <code>keepitsql/core/insert.py</code> <pre><code>class Insert:\n    def insert(\n        self,\n        column_select: list = None,\n        temp_type: str = None,\n    ) -&gt; str:\n        \"\"\"Generates an SQL INSERT statement for inserting data from the source DataFrame into the target table. This method supports selective column insertion and can format the table name for temporary tables. The values from the DataFrame are formatted as strings, with special handling for None values and escaping single quotes.\n\n        Parameters\n        ----------\n        - column_select (list of str, optional): A list specifying which columns from the source DataFrame should be included in the INSERT statement. If None, all columns are used.\n        - temp_type (str, optional): Specifies the type of temporary table. This affects the naming convention used in the SQL statement. For example, 'local' or 'global' temporary tables in MSSQL. If None, a standard table name format is used.\n\n        Returns\n        -------\n        - str: A complete SQL INSERT statement ready for execution. This statement includes the formatted table name, column names, and values to insert.\n\n        Raises\n        ------\n        - ValueError: If `column_select` includes column names not present in the source DataFrame.\n        - AttributeError: If the method is called before a source DataFrame is set.\n\n        Notes\n        -----\n        - The method uses the `format_table_name` function to format the target table name based on the `temp_type` and `target_schema`.\n        - Column names for the INSERT statement are prepared using the `prepare_column_select_list` function, which handles both Pandas and Polars DataFrames.\n        - The source DataFrame values are converted to string format, handling None values appropriately and escaping single quotes to prevent SQL injection or syntax errors.\n        - This method should be called after setting the source DataFrame using `set_source_dataframe`.\n\n        Example usage:\n        ```python\n        from_dataframe = FromDataFrame(target_table=\"your_table_name\", target_schema=\"your_schema_name\")\n        from_dataframe.set_source_dataframe(your_dataframe)\n        insert_statement = from_dataframe.sql_insert(column_select=['col1', 'col2'], temp_type='local')\n        print(insert_statement)\n        ```\n        \"\"\"\n        self.source_dataframe = self.dataframe[column_select] if column_select is not None else self.dataframe\n\n        target_tbl = format_table_name(\n            table_name=self.target_table,\n            schema_name=self.target_schema,\n            temp_table_type=temp_type,\n        )\n\n        # Assuming `prepare_sql_columnlist` handles DataFrame and returns a string of column names for SQL\n        get_column_header = prepare_column_select_list(\n            self.dataframe,\n            column_select,\n        )\n\n        # Convert DataFrame values to strings, handle None values, and escape single quotes\n        formatted_values = self.dataframe.map(\n            lambda x: f\"'{str(x).replace('s', 'd')}'\" if x is not None else 'NULL',\n        )\n\n        # Build the values string by concatenating row values\n        value_list = ',\\n '.join(f\"({','.join(row)})\" for row in formatted_values.values)\n\n        # Construct the full INSERT statement\n        insert_statement = ist.standard_insert.format(\n            table_name=target_tbl,\n            column_names=get_column_header,\n            insert_value_list=value_list,\n        )\n\n        return insert_statement\n</code></pre>"},{"location":"reference/#keepitsql.core.insert.Insert.insert","title":"<code>insert(column_select=None, temp_type=None)</code>","text":"<p>Generates an SQL INSERT statement for inserting data from the source DataFrame into the target table. This method supports selective column insertion and can format the table name for temporary tables. The values from the DataFrame are formatted as strings, with special handling for None values and escaping single quotes.</p>"},{"location":"reference/#keepitsql.core.insert.Insert.insert--parameters","title":"Parameters","text":"<ul> <li>column_select (list of str, optional): A list specifying which columns from the source DataFrame should be included in the INSERT statement. If None, all columns are used.</li> <li>temp_type (str, optional): Specifies the type of temporary table. This affects the naming convention used in the SQL statement. For example, 'local' or 'global' temporary tables in MSSQL. If None, a standard table name format is used.</li> </ul>"},{"location":"reference/#keepitsql.core.insert.Insert.insert--returns","title":"Returns","text":"<ul> <li>str: A complete SQL INSERT statement ready for execution. This statement includes the formatted table name, column names, and values to insert.</li> </ul>"},{"location":"reference/#keepitsql.core.insert.Insert.insert--raises","title":"Raises","text":"<ul> <li>ValueError: If <code>column_select</code> includes column names not present in the source DataFrame.</li> <li>AttributeError: If the method is called before a source DataFrame is set.</li> </ul>"},{"location":"reference/#keepitsql.core.insert.Insert.insert--notes","title":"Notes","text":"<ul> <li>The method uses the <code>format_table_name</code> function to format the target table name based on the <code>temp_type</code> and <code>target_schema</code>.</li> <li>Column names for the INSERT statement are prepared using the <code>prepare_column_select_list</code> function, which handles both Pandas and Polars DataFrames.</li> <li>The source DataFrame values are converted to string format, handling None values appropriately and escaping single quotes to prevent SQL injection or syntax errors.</li> <li>This method should be called after setting the source DataFrame using <code>set_source_dataframe</code>.</li> </ul> <p>Example usage:</p> <pre><code>from_dataframe = FromDataFrame(target_table=\"your_table_name\", target_schema=\"your_schema_name\")\nfrom_dataframe.set_source_dataframe(your_dataframe)\ninsert_statement = from_dataframe.sql_insert(column_select=['col1', 'col2'], temp_type='local')\nprint(insert_statement)\n</code></pre> Source code in <code>keepitsql/core/insert.py</code> <pre><code>def insert(\n    self,\n    column_select: list = None,\n    temp_type: str = None,\n) -&gt; str:\n    \"\"\"Generates an SQL INSERT statement for inserting data from the source DataFrame into the target table. This method supports selective column insertion and can format the table name for temporary tables. The values from the DataFrame are formatted as strings, with special handling for None values and escaping single quotes.\n\n    Parameters\n    ----------\n    - column_select (list of str, optional): A list specifying which columns from the source DataFrame should be included in the INSERT statement. If None, all columns are used.\n    - temp_type (str, optional): Specifies the type of temporary table. This affects the naming convention used in the SQL statement. For example, 'local' or 'global' temporary tables in MSSQL. If None, a standard table name format is used.\n\n    Returns\n    -------\n    - str: A complete SQL INSERT statement ready for execution. This statement includes the formatted table name, column names, and values to insert.\n\n    Raises\n    ------\n    - ValueError: If `column_select` includes column names not present in the source DataFrame.\n    - AttributeError: If the method is called before a source DataFrame is set.\n\n    Notes\n    -----\n    - The method uses the `format_table_name` function to format the target table name based on the `temp_type` and `target_schema`.\n    - Column names for the INSERT statement are prepared using the `prepare_column_select_list` function, which handles both Pandas and Polars DataFrames.\n    - The source DataFrame values are converted to string format, handling None values appropriately and escaping single quotes to prevent SQL injection or syntax errors.\n    - This method should be called after setting the source DataFrame using `set_source_dataframe`.\n\n    Example usage:\n    ```python\n    from_dataframe = FromDataFrame(target_table=\"your_table_name\", target_schema=\"your_schema_name\")\n    from_dataframe.set_source_dataframe(your_dataframe)\n    insert_statement = from_dataframe.sql_insert(column_select=['col1', 'col2'], temp_type='local')\n    print(insert_statement)\n    ```\n    \"\"\"\n    self.source_dataframe = self.dataframe[column_select] if column_select is not None else self.dataframe\n\n    target_tbl = format_table_name(\n        table_name=self.target_table,\n        schema_name=self.target_schema,\n        temp_table_type=temp_type,\n    )\n\n    # Assuming `prepare_sql_columnlist` handles DataFrame and returns a string of column names for SQL\n    get_column_header = prepare_column_select_list(\n        self.dataframe,\n        column_select,\n    )\n\n    # Convert DataFrame values to strings, handle None values, and escape single quotes\n    formatted_values = self.dataframe.map(\n        lambda x: f\"'{str(x).replace('s', 'd')}'\" if x is not None else 'NULL',\n    )\n\n    # Build the values string by concatenating row values\n    value_list = ',\\n '.join(f\"({','.join(row)})\" for row in formatted_values.values)\n\n    # Construct the full INSERT statement\n    insert_statement = ist.standard_insert.format(\n        table_name=target_tbl,\n        column_names=get_column_header,\n        insert_value_list=value_list,\n    )\n\n    return insert_statement\n</code></pre>"},{"location":"reference/#keepitsql.core.upsert.InsertOnConflict","title":"<code>InsertOnConflict</code>","text":"<p>               Bases: <code>Insert</code></p> <p>Class to handle inserting data into a target table with conflict resolution.</p> <p>Attributes:</p> Name Type Description <code>target_table</code> <code>str</code> <p>The name of the target table.</p> <code>target_schema</code> <code>str</code> <p>The schema of the target table.</p> <code>dataframe</code> <code>DataFrame</code> <p>The dataframe containing the data to be inserted.</p> Source code in <code>keepitsql/core/upsert.py</code> <pre><code>class InsertOnConflict(Insert):\n    \"\"\"\n    Class to handle inserting data into a target table with conflict resolution.\n\n    Attributes:\n        target_table (str): The name of the target table.\n        target_schema (str): The schema of the target table.\n        dataframe (DataFrame): The dataframe containing the data to be inserted.\n    \"\"\"\n\n    def __init__(self, target_table, target_schema, dataframe):\n        \"\"\"\n        Initializes the InsertOnConflict class with the target table, target schema, and dataframe.\n\n        Args:\n            target_table (str): The name of the target table.\n            target_schema (str): The schema of the target table.\n            dataframe (DataFrame): The dataframe containing the data to be inserted.\n        \"\"\"\n        self.target_table = target_table\n        self.target_schema = target_schema\n        self.dataframe = dataframe\n\n    def insert_on_conflict(\n        self,\n        source_table: str,\n        match_condition: list,\n        source_schema: str = None,\n        column_exclusion: list = None,\n        temp_type: str = None,\n    ):\n        \"\"\"\n        Creates a SQL insert statement with conflict resolution to insert data from the source table into the target table.\n\n        Args:\n            source_table (str): The name of the source table.\n            match_condition (list): The list of columns to be used as match conditions.\n            source_schema (str, optional): The schema of the source table. Defaults to None.\n            column_exclusion (list, optional): The list of columns to be excluded from the insert. Defaults to None.\n            temp_type (str, optional): The type of temporary table to be used. Defaults to None.\n        \"\"\"\n        insert_stmt = self.insert()\n        update_list = '\\n,'.join\n\n        update_list_col = select_dataframe_column(source_dataframe=self.dataframe, output_type='list')\n\n        match_conditions = ','.join(match_condition)\n\n        update_list = ',\\n'.join(\n            ioc.update_list.format(column=col)\n            for col in update_list_col\n            if col.upper() not in list(map(lambda x: x.upper(), match_condition))\n        )\n\n        on_conflict_statement = ioc.insert_on_conflict.format(\n            insert_statment=insert_stmt, match_condition=match_conditions, update_list=update_list\n        )\n\n        print(on_conflict_statement)\n</code></pre>"},{"location":"reference/#keepitsql.core.upsert.InsertOnConflict.__init__","title":"<code>__init__(target_table, target_schema, dataframe)</code>","text":"<p>Initializes the InsertOnConflict class with the target table, target schema, and dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>target_table</code> <code>str</code> <p>The name of the target table.</p> required <code>target_schema</code> <code>str</code> <p>The schema of the target table.</p> required <code>dataframe</code> <code>DataFrame</code> <p>The dataframe containing the data to be inserted.</p> required Source code in <code>keepitsql/core/upsert.py</code> <pre><code>def __init__(self, target_table, target_schema, dataframe):\n    \"\"\"\n    Initializes the InsertOnConflict class with the target table, target schema, and dataframe.\n\n    Args:\n        target_table (str): The name of the target table.\n        target_schema (str): The schema of the target table.\n        dataframe (DataFrame): The dataframe containing the data to be inserted.\n    \"\"\"\n    self.target_table = target_table\n    self.target_schema = target_schema\n    self.dataframe = dataframe\n</code></pre>"},{"location":"reference/#keepitsql.core.upsert.InsertOnConflict.insert_on_conflict","title":"<code>insert_on_conflict(source_table, match_condition, source_schema=None, column_exclusion=None, temp_type=None)</code>","text":"<p>Creates a SQL insert statement with conflict resolution to insert data from the source table into the target table.</p> <p>Parameters:</p> Name Type Description Default <code>source_table</code> <code>str</code> <p>The name of the source table.</p> required <code>match_condition</code> <code>list</code> <p>The list of columns to be used as match conditions.</p> required <code>source_schema</code> <code>str</code> <p>The schema of the source table. Defaults to None.</p> <code>None</code> <code>column_exclusion</code> <code>list</code> <p>The list of columns to be excluded from the insert. Defaults to None.</p> <code>None</code> <code>temp_type</code> <code>str</code> <p>The type of temporary table to be used. Defaults to None.</p> <code>None</code> Source code in <code>keepitsql/core/upsert.py</code> <pre><code>def insert_on_conflict(\n    self,\n    source_table: str,\n    match_condition: list,\n    source_schema: str = None,\n    column_exclusion: list = None,\n    temp_type: str = None,\n):\n    \"\"\"\n    Creates a SQL insert statement with conflict resolution to insert data from the source table into the target table.\n\n    Args:\n        source_table (str): The name of the source table.\n        match_condition (list): The list of columns to be used as match conditions.\n        source_schema (str, optional): The schema of the source table. Defaults to None.\n        column_exclusion (list, optional): The list of columns to be excluded from the insert. Defaults to None.\n        temp_type (str, optional): The type of temporary table to be used. Defaults to None.\n    \"\"\"\n    insert_stmt = self.insert()\n    update_list = '\\n,'.join\n\n    update_list_col = select_dataframe_column(source_dataframe=self.dataframe, output_type='list')\n\n    match_conditions = ','.join(match_condition)\n\n    update_list = ',\\n'.join(\n        ioc.update_list.format(column=col)\n        for col in update_list_col\n        if col.upper() not in list(map(lambda x: x.upper(), match_condition))\n    )\n\n    on_conflict_statement = ioc.insert_on_conflict.format(\n        insert_statment=insert_stmt, match_condition=match_conditions, update_list=update_list\n    )\n\n    print(on_conflict_statement)\n</code></pre>"},{"location":"reference/#keepitsql.core.upsert.Merge","title":"<code>Merge</code>","text":"<p>Class to handle the merging of data from a source table into a target table using a match condition.</p> <p>Attributes:</p> Name Type Description <code>target_table</code> <code>str</code> <p>The name of the target table.</p> <code>target_schema</code> <code>str</code> <p>The schema of the target table.</p> <code>dataframe</code> <code>DataFrame</code> <p>The dataframe containing the data to be merged.</p> Source code in <code>keepitsql/core/upsert.py</code> <pre><code>class Merge:\n    \"\"\"\n    Class to handle the merging of data from a source table into a target table using a match condition.\n\n    Attributes:\n        target_table (str): The name of the target table.\n        target_schema (str): The schema of the target table.\n        dataframe (DataFrame): The dataframe containing the data to be merged.\n    \"\"\"\n\n    def __init__(self, target_table, target_schema, dataframe):\n        \"\"\"\n        Initializes the Merge class with the target table, target schema, and dataframe.\n\n        Args:\n            target_table (str): The name of the target table.\n            target_schema (str): The schema of the target table.\n            dataframe (DataFrame): The dataframe containing the data to be merged.\n        \"\"\"\n        self.target_table = target_table\n        self.target_schema = target_schema\n        self.dataframe = dataframe\n\n    def merge(\n        self,\n        source_table: str,\n        match_condition: list,\n        source_schema: str = None,\n        column_exclusion: list = None,\n        temp_type: str = None,\n    ) -&gt; str:\n        \"\"\"\n        Creates a SQL merge statement to merge data from the source table into the target table.\n\n        Args:\n            source_table (str): The name of the source table.\n            match_condition (list): The list of columns to be used as match conditions.\n            source_schema (str, optional): The schema of the source table. Defaults to None.\n            column_exclusion (list, optional): The list of columns to be excluded from the merge. Defaults to None.\n            temp_type (str, optional): The type of temporary table to be used. Defaults to None.\n\n        Returns:\n            str: The generated SQL merge statement.\n        \"\"\"\n        target_table = format_table_name(\n            table_name=self.target_table,\n            schema_name=self.target_schema,\n        )\n        source_table = format_table_name(\n            table_name=source_table,\n            schema_name=source_schema,\n            temp_table_type=temp_type,\n        )\n\n        all_columns = select_dataframe_column(\n            source_dataframe=self.dataframe,\n            output_type='list',\n        )\n\n        if column_exclusion is None:\n            column_exclusion = []\n\n        column_inclusion = [col for col in all_columns if col not in match_condition and col not in column_exclusion]\n\n        join_conditions = ',\\n  '.join(\n            mst.merge_condition.format(source_column=col, target_column=col) for col in match_condition\n        )\n\n        matched_condition = ',\\n OR '.join(\n            mst.when_matched_condition.format(target_column=col, source_column=col) for col in column_inclusion\n        )\n\n        merge_update_list = ',\\n'.join(\n            mst.update_list.format(target_column=col, source_column=col) for col in column_inclusion\n        )\n\n        merge_insert_values = ',\\n'.join(mst.merge_insert.format(source_column=col) for col in column_inclusion)\n        merge_insert_columns = ',\\n'.join(\n            mst.merge_insert_columns.format(source_column=col) for col in column_inclusion\n        )\n\n        merge_statement = mst.merge_statement.format(\n            target_table=target_table,\n            source_table=source_table,\n            merge_join_conditions=join_conditions,\n            matched_condition=matched_condition,\n            update_list=merge_update_list,\n            insert_columns=merge_insert_columns,\n            merge_insert_value=merge_insert_values,\n        )\n\n        return merge_statement\n</code></pre>"},{"location":"reference/#keepitsql.core.upsert.Merge.__init__","title":"<code>__init__(target_table, target_schema, dataframe)</code>","text":"<p>Initializes the Merge class with the target table, target schema, and dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>target_table</code> <code>str</code> <p>The name of the target table.</p> required <code>target_schema</code> <code>str</code> <p>The schema of the target table.</p> required <code>dataframe</code> <code>DataFrame</code> <p>The dataframe containing the data to be merged.</p> required Source code in <code>keepitsql/core/upsert.py</code> <pre><code>def __init__(self, target_table, target_schema, dataframe):\n    \"\"\"\n    Initializes the Merge class with the target table, target schema, and dataframe.\n\n    Args:\n        target_table (str): The name of the target table.\n        target_schema (str): The schema of the target table.\n        dataframe (DataFrame): The dataframe containing the data to be merged.\n    \"\"\"\n    self.target_table = target_table\n    self.target_schema = target_schema\n    self.dataframe = dataframe\n</code></pre>"},{"location":"reference/#keepitsql.core.upsert.Merge.merge","title":"<code>merge(source_table, match_condition, source_schema=None, column_exclusion=None, temp_type=None)</code>","text":"<p>Creates a SQL merge statement to merge data from the source table into the target table.</p> <p>Parameters:</p> Name Type Description Default <code>source_table</code> <code>str</code> <p>The name of the source table.</p> required <code>match_condition</code> <code>list</code> <p>The list of columns to be used as match conditions.</p> required <code>source_schema</code> <code>str</code> <p>The schema of the source table. Defaults to None.</p> <code>None</code> <code>column_exclusion</code> <code>list</code> <p>The list of columns to be excluded from the merge. Defaults to None.</p> <code>None</code> <code>temp_type</code> <code>str</code> <p>The type of temporary table to be used. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The generated SQL merge statement.</p> Source code in <code>keepitsql/core/upsert.py</code> <pre><code>def merge(\n    self,\n    source_table: str,\n    match_condition: list,\n    source_schema: str = None,\n    column_exclusion: list = None,\n    temp_type: str = None,\n) -&gt; str:\n    \"\"\"\n    Creates a SQL merge statement to merge data from the source table into the target table.\n\n    Args:\n        source_table (str): The name of the source table.\n        match_condition (list): The list of columns to be used as match conditions.\n        source_schema (str, optional): The schema of the source table. Defaults to None.\n        column_exclusion (list, optional): The list of columns to be excluded from the merge. Defaults to None.\n        temp_type (str, optional): The type of temporary table to be used. Defaults to None.\n\n    Returns:\n        str: The generated SQL merge statement.\n    \"\"\"\n    target_table = format_table_name(\n        table_name=self.target_table,\n        schema_name=self.target_schema,\n    )\n    source_table = format_table_name(\n        table_name=source_table,\n        schema_name=source_schema,\n        temp_table_type=temp_type,\n    )\n\n    all_columns = select_dataframe_column(\n        source_dataframe=self.dataframe,\n        output_type='list',\n    )\n\n    if column_exclusion is None:\n        column_exclusion = []\n\n    column_inclusion = [col for col in all_columns if col not in match_condition and col not in column_exclusion]\n\n    join_conditions = ',\\n  '.join(\n        mst.merge_condition.format(source_column=col, target_column=col) for col in match_condition\n    )\n\n    matched_condition = ',\\n OR '.join(\n        mst.when_matched_condition.format(target_column=col, source_column=col) for col in column_inclusion\n    )\n\n    merge_update_list = ',\\n'.join(\n        mst.update_list.format(target_column=col, source_column=col) for col in column_inclusion\n    )\n\n    merge_insert_values = ',\\n'.join(mst.merge_insert.format(source_column=col) for col in column_inclusion)\n    merge_insert_columns = ',\\n'.join(\n        mst.merge_insert_columns.format(source_column=col) for col in column_inclusion\n    )\n\n    merge_statement = mst.merge_statement.format(\n        target_table=target_table,\n        source_table=source_table,\n        merge_join_conditions=join_conditions,\n        matched_condition=matched_condition,\n        update_list=merge_update_list,\n        insert_columns=merge_insert_columns,\n        merge_insert_value=merge_insert_values,\n    )\n\n    return merge_statement\n</code></pre>"},{"location":"reference/#keepitsql.core.upsert.Upsert","title":"<code>Upsert</code>","text":"<p>Class to handle the upserting (insert or update) of data into a target table.</p> <p>Attributes:</p> Name Type Description <code>target_table</code> <code>str</code> <p>The name of the target table.</p> <code>target_schema</code> <code>str</code> <p>The schema of the target table.</p> <code>dataframe</code> <code>DataFrame</code> <p>The dataframe containing the data to be upserted.</p> Source code in <code>keepitsql/core/upsert.py</code> <pre><code>class Upsert:\n    \"\"\"\n    Class to handle the upserting (insert or update) of data into a target table.\n\n    Attributes:\n        target_table (str): The name of the target table.\n        target_schema (str): The schema of the target table.\n        dataframe (DataFrame): The dataframe containing the data to be upserted.\n    \"\"\"\n\n    def __init__(self, target_table, target_schema, dataframe):\n        \"\"\"\n        Initializes the Upsert class with the target table, target schema, and dataframe.\n\n        Args:\n            target_table (str): The name of the target table.\n            target_schema (str): The schema of the target table.\n            dataframe (DataFrame): The dataframe containing the data to be upserted.\n        \"\"\"\n        self.target_table = target_table\n        self.target_schema = target_schema\n        self.dataframe = dataframe\n        self.__merge_instance = Merge(target_table, target_schema, dataframe)\n        self.__insert_instance = InsertOnConflict(target_table, target_schema, dataframe)\n\n    def upsert(\n        self,\n        source_table: str,\n        match_condition: list,\n        source_schema: str = None,\n        column_exclusion: list = None,\n        temp_type: str = None,\n        dbms_output=None,\n    ):\n        \"\"\"\n        Creates an upsert statement based on the DBMS type. If the DBMS supports MERGE, it creates a merge statement.\n        Otherwise, it creates an insert-on-conflict statement.\n\n        Args:\n            source_table (str): The name of the source table.\n            match_condition (list): The list of columns to be used as match conditions.\n            source_schema (str, optional): The schema of the source table. Defaults to None.\n            column_exclusion (list, optional): The list of columns to be excluded from the upsert. Defaults to None.\n            temp_type (str, optional): The type of temporary table to be used. Defaults to None.\n            dbms_output (str, optional): The DBMS type. Defaults to None.\n\n        Returns:\n            str: The generated upsert statement.\n        \"\"\"\n        if get_upsert_type_by_dbms(dbms_output) == 'MERGE':\n            return self.__merge_instance.merge(\n                source_table=source_table,\n                match_condition=match_condition,\n                source_schema=source_schema,\n                column_exclusion=column_exclusion,\n                temp_type=temp_type,\n            )\n        else:\n            return self.__insert_instance.insert_on_conflict(\n                source_table=source_table,\n                match_condition=match_condition,\n                source_schema=source_schema,\n                column_exclusion=column_exclusion,\n                temp_type=temp_type,\n            )\n</code></pre>"},{"location":"reference/#keepitsql.core.upsert.Upsert.__init__","title":"<code>__init__(target_table, target_schema, dataframe)</code>","text":"<p>Initializes the Upsert class with the target table, target schema, and dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>target_table</code> <code>str</code> <p>The name of the target table.</p> required <code>target_schema</code> <code>str</code> <p>The schema of the target table.</p> required <code>dataframe</code> <code>DataFrame</code> <p>The dataframe containing the data to be upserted.</p> required Source code in <code>keepitsql/core/upsert.py</code> <pre><code>def __init__(self, target_table, target_schema, dataframe):\n    \"\"\"\n    Initializes the Upsert class with the target table, target schema, and dataframe.\n\n    Args:\n        target_table (str): The name of the target table.\n        target_schema (str): The schema of the target table.\n        dataframe (DataFrame): The dataframe containing the data to be upserted.\n    \"\"\"\n    self.target_table = target_table\n    self.target_schema = target_schema\n    self.dataframe = dataframe\n    self.__merge_instance = Merge(target_table, target_schema, dataframe)\n    self.__insert_instance = InsertOnConflict(target_table, target_schema, dataframe)\n</code></pre>"},{"location":"reference/#keepitsql.core.upsert.Upsert.upsert","title":"<code>upsert(source_table, match_condition, source_schema=None, column_exclusion=None, temp_type=None, dbms_output=None)</code>","text":"<p>Creates an upsert statement based on the DBMS type. If the DBMS supports MERGE, it creates a merge statement. Otherwise, it creates an insert-on-conflict statement.</p> <p>Parameters:</p> Name Type Description Default <code>source_table</code> <code>str</code> <p>The name of the source table.</p> required <code>match_condition</code> <code>list</code> <p>The list of columns to be used as match conditions.</p> required <code>source_schema</code> <code>str</code> <p>The schema of the source table. Defaults to None.</p> <code>None</code> <code>column_exclusion</code> <code>list</code> <p>The list of columns to be excluded from the upsert. Defaults to None.</p> <code>None</code> <code>temp_type</code> <code>str</code> <p>The type of temporary table to be used. Defaults to None.</p> <code>None</code> <code>dbms_output</code> <code>str</code> <p>The DBMS type. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The generated upsert statement.</p> Source code in <code>keepitsql/core/upsert.py</code> <pre><code>def upsert(\n    self,\n    source_table: str,\n    match_condition: list,\n    source_schema: str = None,\n    column_exclusion: list = None,\n    temp_type: str = None,\n    dbms_output=None,\n):\n    \"\"\"\n    Creates an upsert statement based on the DBMS type. If the DBMS supports MERGE, it creates a merge statement.\n    Otherwise, it creates an insert-on-conflict statement.\n\n    Args:\n        source_table (str): The name of the source table.\n        match_condition (list): The list of columns to be used as match conditions.\n        source_schema (str, optional): The schema of the source table. Defaults to None.\n        column_exclusion (list, optional): The list of columns to be excluded from the upsert. Defaults to None.\n        temp_type (str, optional): The type of temporary table to be used. Defaults to None.\n        dbms_output (str, optional): The DBMS type. Defaults to None.\n\n    Returns:\n        str: The generated upsert statement.\n    \"\"\"\n    if get_upsert_type_by_dbms(dbms_output) == 'MERGE':\n        return self.__merge_instance.merge(\n            source_table=source_table,\n            match_condition=match_condition,\n            source_schema=source_schema,\n            column_exclusion=column_exclusion,\n            temp_type=temp_type,\n        )\n    else:\n        return self.__insert_instance.insert_on_conflict(\n            source_table=source_table,\n            match_condition=match_condition,\n            source_schema=source_schema,\n            column_exclusion=column_exclusion,\n            temp_type=temp_type,\n        )\n</code></pre>"},{"location":"get-started/from-dataframe/","title":"From dataframe","text":""},{"location":"get-started/from-dataframe/#1-creating-an-insert-statement","title":"1. Creating an Insert Statement","text":"<p>To generate an INSERT statement from a dataframe, use the FromDataframe class:</p> <pre><code>import pandas as pd\nfrom keepitsql.core.fromdataframe \n\n\n# Sample data\ndata = {\n    \"ItemID\": [\"ID101\", \"ID102\", \"ID103\", \"ID104\", \"ID105\"],\n    \"ItemName\": [\"Laptop\", \"Desk Chair\", \"USB-C Cable\", \"Monitor\", \"Mouse\"],\n    \"Description\": [\n        \"15-inch laptop with 8GB RAM\",\n        \"Ergonomic office chair\",\n        \"1m USB-C charging cable\",\n        \"24-inch LED monitor\",\n        \"Magic Apple\",\n    ],\n    \"Category\": [\"Electronics\", \"Furniture\", \"Electronics\", \"Electronics\", \"Accessories\"],\n    \"Quantity\": [10, 5, 50, 8, 4],\n    \"Location\": [\"Warehouse A\", \"Warehouse B\", \"Warehouse A\", \"Warehouse C\", \"Warehouse C\"],\n}\n\ndf = pd.DataFrame(data)\n\n# Generate Insert Statement\ninsert_generator = FromDataframe(target_table=\"your_table_name\", dataframe=df, target_schema=\"your_schema\")\ninsert_statement = insert_generator.insert()\nprint(insert_statement)\n</code></pre>"},{"location":"get-started/from-dataframe/#2-creating-an-upsert-statement","title":"2. Creating an Upsert Statement","text":"<p>The FromDataframe class can also generate an UPSERT statement, dynamically choosing between a MERGE or INSERT ON CONFLICT statement based on the target database:</p> <pre><code>\nimport pandas as pd\nfrom keepitsql.core.fromdataframe\n\n\n# Sample data\ndata = {\n    \"ItemID\": [\"ID101\", \"ID102\", \"ID103\", \"ID104\", \"ID105\"],\n    \"ItemName\": [\"Laptop\", \"Desk Chair\", \"USB-C Cable\", \"Monitor\", \"Mouse\"],\n    \"Description\": [\n        \"15-inch laptop with 8GB RAM\",\n        \"Ergonomic office chair\",\n        \"1m USB-C charging cable\",\n        \"24-inch LED monitor\",\n        \"Magic Apple\",\n    ],\n    \"Category\": [\"Electronics\", \"Furniture\", \"Electronics\", \"Electronics\", \"Accessories\"],\n    \"Quantity\": [10, 5, 50, 8, 4],\n    \"Location\": [\"Warehouse A\", \"Warehouse B\", \"Warehouse A\", \"Warehouse C\", \"Warehouse C\"],\n}\n\ndf = pd.DataFrame(data)\n\n# Generate Upsert Statement\nupsert_generator = FromDataframe(\n    target_table=\"your_table_name\",\n    dataframe=df,\n    target_schema=\"your_schema\",\n    source_table=\"source_table_name\",\n    match_condition=[\"ItemID\"],\n    dbms_output=\"postgresql\"  # or \"mssql\", \"oracle\", etc.\n)\nupsert_statement = upsert_generator.upsert()\nprint(upsert_statement)\n\n</code></pre>"},{"location":"get-started/from-dataframe/#dbms-upsert-types","title":"DBMS Upsert Types","text":"<p>The following table shows the supported DBMS and their respective upsert types:</p> DMBS DBMS Output Parameter Upsert Type Oracle MERGE SQL Server MERGE MERGE IBM Db2 MERGE MERGE PostgreSQL postgresql ON CONFLICT SQLite sqlite ON CONFLICT Teradata teradata MERGE SAP HANA sap_hana MERGE Snowflake snowflake MERGE Redshift redshift MERGE BigQuery bigquery MERGE"}]}